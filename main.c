/*
 *Name:			Anthony Neher
 *Description:  keyboard synth
 */

#include <avr/io.h>
#include <avr/interrupt.h>
void dac_init(void);
extern void clock_init(void);
void event_init(void);
void DMA_init(uint16_t addy);
void amp_init(void);
void usart_d0_init(void);
uint8_t usart_d0_in_char(void);
void stop(void);
void period(uint16_t per);
void timer_init(void);

uint16_t arrayadr;
volatile char character;//character recieved from usart
volatile uint16_t first=0;
uint8_t saw = 0;

const uint16_t sine[] = {0x800,0x832,0x864,0x896,0x8c8,0x8fa,0x92c,0x95e,0x98f,0x9c0,0x9f1,0xa22,0xa52,0xa82,0xab1,0xae0,0xb0f,0xb3d,0xb6b,0xb98,
0xbc5,0xbf1,0xc1c,0xc47,0xc71,0xc9a,0xcc3,0xceb,0xd12,0xd39,0xd5f,0xd83,0xda7,0xdca,0xded,0xe0e,0xe2e,0xe4e,0xe6c,0xe8a,
0xea6,0xec1,0xedc,0xef5,0xf0d,0xf24,0xf3a,0xf4f,0xf63,0xf76,0xf87,0xf98,0xfa7,0xfb5,0xfc2,0xfcd,0xfd8,0xfe1,0xfe9,0xff0,
0xff5,0xff9,0xffd,0xffe,0xfff,0xffe,0xffd,0xff9,0xff5,0xff0,0xfe9,0xfe1,0xfd8,0xfcd,0xfc2,0xfb5,0xfa7,0xf98,0xf87,0xf76,
0xf63,0xf4f,0xf3a,0xf24,0xf0d,0xef5,0xedc,0xec1,0xea6,0xe8a,0xe6c,0xe4e,0xe2e,0xe0e,0xded,0xdca,0xda7,0xd83,0xd5f,0xd39,
0xd12,0xceb,0xcc3,0xc9a,0xc71,0xc47,0xc1c,0xbf1,0xbc5,0xb98,0xb6b,0xb3d,0xb0f,0xae0,0xab1,0xa82,0xa52,0xa22,0x9f1,0x9c0,
0x98f,0x95e,0x92c,0x8fa,0x8c8,0x896,0x864,0x832,0x800,0x7cd,0x79b,0x769,0x737,0x705,0x6d3,0x6a1,0x670,0x63f,0x60e,0x5dd,
0x5ad,0x57d,0x54e,0x51f,0x4f0,0x4c2,0x494,0x467,0x43a,0x40e,0x3e3,0x3b8,0x38e,0x365,0x33c,0x314,0x2ed,0x2c6,0x2a0,0x27c,
0x258,0x235,0x212,0x1f1,0x1d1,0x1b1,0x193,0x175,0x159,0x13e,0x123,0x10a,0xf2,0xdb,0xc5,0xb0,0x9c,0x89,0x78,0x67,
0x58,0x4a,0x3d,0x32,0x27,0x1e,0x16,0xf,0xa,0x6,0x2,0x1,0x0,0x1,0x2,0x6,0xa,0xf,0x16,0x1e,
0x27,0x32,0x3d,0x4a,0x58,0x67,0x78,0x89,0x9c,0xb0,0xc5,0xdb,0xf2,0x10a,0x123,0x13e,0x159,0x175,0x193,0x1b1,
0x1d1,0x1f1,0x212,0x235,0x258,0x27c,0x2a0,0x2c6,0x2ed,0x314,0x33c,0x365,0x38e,0x3b8,0x3e3,0x40e,0x43a,0x467,0x494,0x4c2,
0x4f0,0x51f,0x54e,0x57d,0x5ad,0x5dd,0x60e,0x63f,0x670,0x6a1,0x6d3,0x705,0x737,0x769,0x79b,0x7cd,0x800};

const uint16_t sawtooth[] = {0x10,0x20,0x30,0x40,0x50,0x60,0x70,0x80,0x90,0xa0,0xb0,0xc0,0xd0,0xe0,0xf0,0x100,0x110,0x120,0x130,0x140,
0x150,0x160,0x170,0x180,0x190,0x1a0,0x1b0,0x1c0,0x1d0,0x1e0,0x1f0,0x200,0x210,0x220,0x230,0x240,0x250,0x260,0x270,0x280,
0x290,0x2a0,0x2b0,0x2c0,0x2d0,0x2e0,0x2f0,0x300,0x310,0x320,0x330,0x340,0x350,0x360,0x370,0x380,0x390,0x3a0,0x3b0,0x3c0,
0x3d0,0x3e0,0x3f0,0x400,0x410,0x420,0x430,0x440,0x450,0x460,0x470,0x480,0x490,0x4a0,0x4b0,0x4c0,0x4d0,0x4e0,0x4f0,0x500,
0x510,0x520,0x530,0x540,0x550,0x560,0x570,0x580,0x590,0x5a0,0x5b0,0x5c0,0x5d0,0x5e0,0x5f0,0x600,0x610,0x620,0x630,0x640,
0x650,0x660,0x670,0x680,0x690,0x6a0,0x6b0,0x6c0,0x6d0,0x6e0,0x6f0,0x700,0x710,0x720,0x730,0x740,0x750,0x760,0x770,0x780,
0x790,0x7a0,0x7b0,0x7c0,0x7d0,0x7e0,0x7f0,0x800,0x80f,0x81f,0x82f,0x83f,0x84f,0x85f,0x86f,0x87f,0x88f,0x89f,0x8af,0x8bf,
0x8cf,0x8df,0x8ef,0x8ff,0x90f,0x91f,0x92f,0x93f,0x94f,0x95f,0x96f,0x97f,0x98f,0x99f,0x9af,0x9bf,0x9cf,0x9df,0x9ef,0x9ff,
0xa0f,0xa1f,0xa2f,0xa3f,0xa4f,0xa5f,0xa6f,0xa7f,0xa8f,0xa9f,0xaaf,0xabf,0xacf,0xadf,0xaef,0xaff,0xb0f,0xb1f,0xb2f,0xb3f,
0xb4f,0xb5f,0xb6f,0xb7f,0xb8f,0xb9f,0xbaf,0xbbf,0xbcf,0xbdf,0xbef,0xbff,0xc0f,0xc1f,0xc2f,0xc3f,0xc4f,0xc5f,0xc6f,0xc7f,
0xc8f,0xc9f,0xcaf,0xcbf,0xccf,0xcdf,0xcef,0xcff,0xd0f,0xd1f,0xd2f,0xd3f,0xd4f,0xd5f,0xd6f,0xd7f,0xd8f,0xd9f,0xdaf,0xdbf,
0xdcf,0xddf,0xdef,0xdff,0xe0f,0xe1f,0xe2f,0xe3f,0xe4f,0xe5f,0xe6f,0xe7f,0xe8f,0xe9f,0xeaf,0xebf,0xecf,0xedf,0xeef,0xeff,
0xf0f,0xf1f,0xf2f,0xf3f,0xf4f,0xf5f,0xf6f,0xf7f,0xf8f,0xf9f,0xfaf,0xfbf,0xfcf,0xfdf,0xfef,0xfff};

int main(void)
{
	clock_init();
    dac_init();
	event_init();
	timer_init();
	DMA_init(sine);
	amp_init();
	usart_d0_init();
	sei();//enable global interrupts
	PMIC.CTRL = PMIC_LOLVLEN_bm;
    while (1){
		
	}
}

void DMA_init(uint16_t addy){
	arrayadr = addy;//start with sine wave
	DMA.CTRL = PIN6_bm;//software reset
	DMA.CH0.CTRLA = PIN6_bm;//also reset
	DMA.CH0.CTRLA = DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm | DMA_CH_BURSTLEN0_bm;
	//single shot transfer of two bytes repeating
	DMA.CH0.TRIGSRC = 1;//event triggers dma
	DMA.CH0.ADDRCTRL = DMA_CH_SRCRELOAD_gm | DMA_CH_SRCDIR0_bm | PIN3_bm | PIN0_bm;
	//reload at end of transaction/increment source & increment dest/reload after burst
	DMA_CH0_SRCADDR0 = (uint8_t)(arrayadr);
	DMA_CH0_SRCADDR1 = (uint8_t)((uint16_t)(arrayadr>>8));
	DMA_CH0_SRCADDR2 = (uint8_t)((uint32_t)(arrayadr>>16));
	DMA_CH0_DESTADDR0 = (uint8_t)(&DACA_CH1DATA);//writes to channel 1
	DMA_CH0_DESTADDR1 = (uint8_t)((uint16_t)(&DACA_CH1DATA) >> 8);
	DMA_CH0_DESTADDR2 = (uint8_t)((uint32_t)(&DACA_CH1DATA) >> 16);
	DMA.CH0.TRFCNT = 512;// 256 * 2 bytes
	
	DMA.CTRL = PIN7_bm;//enable dma
	DMA.CH0.CTRLA |= DMA_CH_ENABLE_bm;//enable ch0 dma
}

void event_init(void){
	EVSYS.CH0MUX = EVSYS_CHMUX_TCC0_OVF_gc;
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;//both events occur when tcc0 overflows
	return;
}
void dac_init(void){
	DACA.CTRLB = PIN6_bm | PIN1_bm;//dual channel and ch1 ev trigger so no cpu
	DACA.CTRLC = DAC_REFSEL_AREFB_gc;//
	DACA.CTRLA = DAC_ENABLE_bm | DAC_CH1EN_bm;//enable overall and ch0 output
	return;
}

void amp_init(void){
	PORTC.DIRSET = PIN7_bm;//set pin7 output
	PORTC.OUTSET = PIN7_bm;//set make sure amp doesn't power down
	PORTA.DIRSET = PIN3_bm;//analog output
}
void usart_d0_init(void) {
	PORTD.DIRCLR=PIN2_bm; //makes txd pin input
	PORTD.DIRSET=PIN3_bm; //makes rxd pin output
	PORTD.OUTSET=PIN3_bm;
	USARTD0.BAUDCTRLA=0x2E; //Bsel to 11
	USARTD0.BAUDCTRLB=0x98; //Bscale to -7
	USARTD0.CTRLB = USART_RXEN_bm | USART_TXEN_bm; //enables TX and Rx
	USARTD0.CTRLC = 0x03;//8 bit channel size
	USARTD0.CTRLA = PIN4_bm;//interrupt generated on receive complete
	return;
}
ISR(USARTD0_RXC_vect){
	character = USARTD0.DATA;
	usart_d0_outchar(character);
	if(first)
	{
		TCD0.CNT=0;
		TCD0.PER = 0x500;
	}
	else
	{
		TCD0.CNT = 0;
	}
	keychange(character);
	first=1;
}
ISR(TCD0_OVF_vect){
	stop();
	TCD0.CTRLA = 0;//turn off counter
	TCD0.PER = 0x1FF0;
	first = 0;
}
void period(uint16_t per){
	TCC0.PER = per;//set period
}
void stop(void){
	TCC0.CTRLA = 0;//turn off tcc0
}
void timer_init(void){
	TCC0.CTRLA = TC_CLKSEL_DIV1_gc;//turn timer on
	TCC0.PER=0;//set period to 0
	TCD0.PER = 0x1FF0;
	TCD0.INTCTRLA = 1;//enable tcd0 interrupt
	TCD0.CNT= 0;
}
void usart_d0_outchar(char letter){
	USARTD0.DATA = letter;
}
char usart_d0_inchar(char letter){
	while (!(USARTD0_STATUS & USART_RXCIF_bm));
	letter = USARTD0.DATA;
	return letter;
}
void keychange(void){
	switch(character){
		case 's':
			if(saw){//if statement to switch source table
				DMA_init(sine);
				saw = 0;
			}
			else{
				DMA_init(sawtooth);
				saw = 1;
			}
			break;
		case 'u':
			period(72);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
				
		case 'w':
			period(122);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
				
		case 'e':
			period(108);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
				
		case 'r':
			period(96);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
				
		case 't':
			period(91);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
			
		case 'y':
			period(81);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
				
		case 'i':
			period(64);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
			
		case '3':
			period(115);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
			
		case '4':
			period(102);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
		
		case '6':
			period(86);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
		
		case '7':
			period(76);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
		
		case '8':
			period(68);
			TCC0.CTRLA |= TC_CLKSEL_DIV1_gc;
			TCD0.CTRLA |= TC_CLKSEL_DIV1024_gc;//turn timer on
			break;
	}
}
